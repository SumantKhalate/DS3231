/* An STM32 HAL library written for the DS3231 real-time clock IC. */
/* Library by @eepj www.github.com/eepj */
#include "DS3231.h"
#include "main.h"

#ifdef __cplusplus
extern "C"{
#endif

uint8_t const days_in_month [12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
uint8_t const dow[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

I2C_HandleTypeDef *DS3231_device;

/**
 * @brief Initializes the DS3231 module. Set clock halt bit to 0 to start timing.
 * @param hi2c User I2C handle pointer.
 */
HAL_StatusTypeDef DS3231_Init(I2C_HandleTypeDef *i2cHandle) {
	DS3231_device = i2cHandle;
	HAL_StatusTypeDef status;
	status = DS3231_SetAlarm1IntEn(DS3231_DISABLED);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetAlarm2IntEn(DS3231_DISABLED);
	if (status != HAL_OK)
		return status;
	status = DS3231_ClearAlarm1Flag();
	if (status != HAL_OK)
		return status;
	status = DS3231_ClearAlarm2Flag();
	if (status != HAL_OK)
		return status;
	status = DS3231_SetInterruptMode(DS3231_ALARM_INTERRUPT);
	if (status != HAL_OK)
		return status;
	return DS3231_Set32kHzOutput(DS3231_DISABLED);
}

/**
 * @brief Enables battery-backed square wave output at the INT#/SQW pin.
 * @param enable Enable, DS3231_ENABLED or DS3231_DISABLED.
 */
HAL_StatusTypeDef DS3231_SetBatterySquareWave(DS3231_State enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0xBF) | ((enable & 0x01) << DS3231_BBSQW);
	return DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
}

HAL_StatusTypeDef DS3231_GetBatterySquareWave(DS3231_State *enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	*enable = (control >> DS3231_BBSQW) & 0x01;
	return status;
}

/**
 * @brief Enables clock oscillator.
 * @param enable Enable, DS3231_ENABLED or DS3231_DISABLED.
 */
HAL_StatusTypeDef DS3231_SetOscillator(DS3231_State enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0x7F) | ((!enable & 0x01) << DS3231_EOSC);
	return DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
}

/**
 * @brief Check whether the clock oscillator is stopped.
 * @return Oscillator stopped flag (OSF) bit, 0 or 1.
 */
HAL_StatusTypeDef DS3231_GetOscillatorStoppedFlag(DS3231_State *enable) {
	uint8_t data;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_STATUS, &data);
	*enable = !(data >> DS3231_OSF) & 0x01;
	return status;
}

/**
 * @brief Enable the 32kHz output.
 * @param enable Enable, DS3231_ENABLE or DS3231_DISABLE.
 */
HAL_StatusTypeDef DS3231_Set32kHzOutput(DS3231_State enable) {
	uint8_t temp;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_STATUS, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0xF7;
	temp |= (enable << DS3231_EN32KHZ);
	return DS3231_WriteRegister(DS3231_REG_STATUS, &temp);
}

/**
 * @brief Check whether the 32kHz output is enabled.
 * @return EN32kHz flag bit, 0 or 1.
 */
HAL_StatusTypeDef DS3231_Get32kHzEnabled(DS3231_State *enable) {
	uint8_t data;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_STATUS, &data);
	*enable = (data >> DS3231_EN32KHZ) & 0x01;
	return status;
}

/**
 * @brief Set the interrupt mode to either alarm interrupt or square wave interrupt.
 * @param mode Interrupt mode to set, DS3231_ALARM_INTERRUPT or DS3231_SQUARE_WAVE_INTERRUPT.
 */
HAL_StatusTypeDef DS3231_SetInterruptMode(DS3231_InterruptMode mode) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0xFB) | ((mode & 0x01) << DS3231_INTCN);
	return DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
}

HAL_StatusTypeDef DS3231_GetInterruptMode(DS3231_InterruptMode *mode) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	*mode = (control >> DS3231_INTCN) & 0x01;
	return status;
}

/**
 * @brief Set frequency of the square wave output
 * @param rate Frequency to set, DS3231_1HZ, DS3231_1024HZ, DS3231_4096HZ or DS3231_8192HZ.
 */
HAL_StatusTypeDef DS3231_SetRateSelect(DS3231_Rate rate) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0xE7) | ((rate & 0x03) << DS3231_RS1);
	return DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
}

HAL_StatusTypeDef DS3231_GetRateSelect(DS3231_Rate *rate) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	*rate = (control >> DS3231_RS1) & 0x03;
	return status;
}

/**
 * @brief Get the integer part of the temperature.
 * @return Integer part of the temperature, -127 to 127.

HAL_StatusTypeDef DS3231_GetTemperatureInteger(int8_t *temp_int) {
	return DS3231_ReadRegister(DS3231_REG_TEMP_MSB, (uint8_t *)temp_int);
}

*
 * @brief Get the fractional part of the temperature to 2 decimal places.
 * @return Fractional part of the temperature, 0, 25, 50 or 75.

HAL_StatusTypeDef DS3231_GetTemperatureFraction(uint8_t *temp_frac) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_TEMP_LSB, temp_frac);
	*temp_frac = (*temp_frac >> 6) * 25;
	return status;
}*/

HAL_StatusTypeDef DS3231_GetTemperature(float *temp_real) {
	HAL_StatusTypeDef status;
	uint8_t buffer[2];

	status = DS3231_ReadRegisters(DS3231_REG_TEMP_MSB, buffer, 2);
	if (status != HAL_OK)
		return status;

	*temp_real = (buffer[0] + (buffer[1] >> 6) * 0.25f);

	return status;
}

/**
 * @brief Clears alarm 1 matched flag. Matched flags must be cleared before the next match or the next interrupt will be masked.
 */
HAL_StatusTypeDef DS3231_ClearAlarm1Flag(void) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_STATUS, &control);
	if (status != HAL_OK)
		return status;
	control &= ~(0x01 << DS3231_A1F);
	return DS3231_WriteRegister(DS3231_REG_STATUS, &control);
}

/*
 * @brief Enables alarm 1.
 * @param enable Enable, DS3231_ENABLED or DS3231_DISABLED.
*/

HAL_StatusTypeDef DS3231_SetAlarm1IntEn(DS3231_State enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0xFE) | ((enable & 0x01) << DS3231_A1IE);
	DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	return DS3231_SetInterruptMode(DS3231_ALARM_INTERRUPT);
}

HAL_StatusTypeDef DS3231_GetAlarm1IntEn(DS3231_State *enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	*enable = (control >> DS3231_A1IE ) & 0x01;
	return status;
}

/*
*
 * @brief Set alarm 1 second to match. Does not change alarm 1 matching mode.
 * @param second Second, 0 to 59.

HAL_StatusTypeDef DS3231_SetAlarm1Second(uint8_t second) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A1_SECOND, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a1m1 = temp | (DS3231_EncodeBCD(second) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A1_SECOND, &a1m1);
}

*
 * @brief Set alarm 1 minute to match. Does not change alarm 1 matching mode.
 * @param minute Minute, 0 to 59.

HAL_StatusTypeDef DS3231_SetAlarm1Minute(uint8_t minute) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A1_MINUTE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a1m2 = temp | (DS3231_EncodeBCD(minute) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A1_MINUTE, &a1m2);
}

*
 * @brief Set alarm 1 hour to match. Does not change alarm 1 matching mode.
 * @param hour Hour, 0 to 59.

HAL_StatusTypeDef DS3231_SetAlarm1Hour(uint8_t hour_24mode) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A1_HOUR, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a1m3 = temp | (DS3231_EncodeBCD(hour_24mode) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A1_HOUR, &a1m3);
}

*
 * @brief Set alarm 1 date. Alarm 1 can only be set to match either date or day. Does not change alarm 1 matching mode.
 * @param date Date, 0 to 31.

HAL_StatusTypeDef DS3231_SetAlarm1Date(uint8_t date) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A1_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a1m4 = temp | (DS3231_EncodeBCD(date) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A1_DATE, &a1m4);
}

*
 * @brief Set alarm 1 day. Alarm 1 can only be set to match either date or day. Does not change alarm 1 matching mode.
 * @param day Days since last Sunday, 1 to 7.

HAL_StatusTypeDef DS3231_SetAlarm1Day(uint8_t day) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A1_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a1m4 = temp | (0x01 << DS3231_DYDT)
			| (DS3231_EncodeBCD(day) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A1_DATE, &a1m4);
}

*
 * @brief Set alarm 1 mode.
 * @param alarmMode Alarm 1 mode, DS3231_A1_EVERY_S, DS3231_A1_MATCH_S, DS3231_A1_MATCH_S_M, DS3231_A1_MATCH_S_M_H, DS3231_A1_MATCH_S_M_H_DATE or DS3231_A1_MATCH_S_M_H_DAY.

HAL_StatusTypeDef DS3231_SetAlarm1Mode(DS3231_Alarm1Mode alarmMode) {
	uint8_t temp;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_A1_SECOND, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 0) & 0x01) << DS3231_AXMY);
	status = DS3231_WriteRegister(DS3231_REG_A1_SECOND, &temp);
	if (status != HAL_OK)
		return status;
	status = DS3231_ReadRegister(DS3231_REG_A1_MINUTE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 1) & 0x01) << DS3231_AXMY);
	status = DS3231_WriteRegister(DS3231_REG_A1_MINUTE, &temp);
	if (status != HAL_OK)
		return status;
	status = DS3231_ReadRegister(DS3231_REG_A1_HOUR, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 2) & 0x01) << DS3231_AXMY);
	status = DS3231_WriteRegister(DS3231_REG_A1_HOUR, &temp);
	if (status != HAL_OK)
		return status;
	status = DS3231_ReadRegister(DS3231_REG_A1_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 3) & 0x01) << DS3231_AXMY)
			| (alarmMode & 0x80);
	return DS3231_WriteRegister(DS3231_REG_A1_DATE, &temp);
}
*/

HAL_StatusTypeDef DS3231_SetAlarm1(D3231_Alarm1 *A1_st) {
	HAL_StatusTypeDef status;
	uint8_t A1M1 = (A1_st->Mode & 0x01) << 7; // Seconds bit 7.
	uint8_t A1M2 = (A1_st->Mode & 0x02) << 6; // Minutes bit 7.
	uint8_t A1M3 = (A1_st->Mode & 0x04) << 5; // Hour bit 7.
	uint8_t A1M4 = (A1_st->Mode & 0x08) << 4; // Day/Date bit 7.
	uint8_t DY_DT = (A1_st->Mode & 0x10) << 2; // Day/Date bit 6. Date when 0, day of week when 1.

	uint8_t data[4] = {
			DS3231_EncodeBCD(A1_st->Seconds) | A1M1,
			DS3231_EncodeBCD(A1_st->Minutes) | A1M2,
			DS3231_EncodeBCD(A1_st->Hours)	| A1M3,
			DS3231_EncodeBCD(A1_st->DayDate) | DY_DT| A1M4,
	};

	status = DS3231_WriteRegisters(DS3231_REG_A1_SECOND, data, 4);
	if (status != HAL_OK)
			return status;
	return DS3231_SetAlarm1IntEn(A1_st->IntEn);
}

HAL_StatusTypeDef DS3231_GetAlarm1(D3231_Alarm1 *A1_st) {
	HAL_StatusTypeDef status;
	uint8_t data[4];
	status = DS3231_ReadRegisters(DS3231_REG_A1_SECOND, data, 4);
	if (status != HAL_OK)
		return status;

	uint8_t Mode = (data[0] & 0x80) >> 7	// A1M1
				 | (data[1] & 0x80) >> 6	// A1M2
				 | (data[2]& 0x80) >> 5		// A1M3
				 | (data[3]& 0x80) >> 4		// A1M4
				 | (data[3] & 0x40) >> 2;	// DY_DT
	A1_st->Mode = Mode;

	A1_st->Seconds = DS3231_DecodeBCD(data[0] & 0x7F);
	A1_st->Minutes = DS3231_DecodeBCD(data[1] & 0x7F);
	A1_st->Hours = DS3231_DecodeBCD(data[2] & 0x3F);

	uint8_t DayDate =  (data[3] & 0x40) >> 6;
	if (DayDate)
		A1_st->DayDate = DS3231_DecodeBCD(data[3] & 0x0F);
	else
		A1_st->DayDate = DS3231_DecodeBCD(data[3] & 0x3F);

	return DS3231_GetAlarm1IntEn(&A1_st->IntEn);
}

/**
 * @brief Clears alarm 2 matched flag. Matched flags must be cleared before the next match or the next interrupt will be masked.
 */
HAL_StatusTypeDef DS3231_ClearAlarm2Flag(void) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_STATUS, &control);
	if (status != HAL_OK)
		return status;
	control &= ~(0x01 << DS3231_A2F);
	return DS3231_WriteRegister(DS3231_REG_STATUS, &control);
}

/**
 * @brief Enables alarm 2.
 * @param enable Enable, DS3231_ENABLED or DS3231_DISABLED.
 */
HAL_StatusTypeDef DS3231_SetAlarm2IntEn(DS3231_State enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	control = (control & 0xFD) | ((enable & 0x01) << DS3231_A2IE);
	status = DS3231_WriteRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	return DS3231_SetInterruptMode(DS3231_ALARM_INTERRUPT);
}

HAL_StatusTypeDef DS3231_GetAlarm2IntEn(DS3231_State *enable) {
	uint8_t control;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &control);
	if (status != HAL_OK)
		return status;
	*enable = (control >> DS3231_A2IE) & 0x01;
	return status;
}

/**
 * @brief Set alarm 2 minute to match. Does not change alarm 2 matching mode.
 * @param minute Minute, 0 to 59.

HAL_StatusTypeDef DS3231_SetAlarm2Minute(uint8_t minute) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A2_MINUTE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a2m2 = temp | (DS3231_EncodeBCD(minute) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A2_MINUTE, &a2m2);
}

*
 * @brief Set alarm 2 hour to match. Does not change alarm 2 matching mode.
 * @param hour Hour to match in 24h format, 0 to 23.

HAL_StatusTypeDef DS3231_SetAlarm2Hour(uint8_t hour_24mode) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A2_HOUR, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a2m3 = temp | (DS3231_EncodeBCD(hour_24mode) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A2_HOUR, &a2m3);
}

*
 * @brief Set alarm 2 date. Alarm 2 can only be set to match either date or day. Does not change alarm 2 matching mode.
 * @param date Date, 0 to 31.

HAL_StatusTypeDef DS3231_SetAlarm2Date(uint8_t date) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A2_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a2m4 = temp | (DS3231_EncodeBCD(date) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A2_DATE, &a2m4);
}

*
 * @brief Set alarm 2 day. Alarm 2 can only be set to match either date or day. Does not change alarm 2 matching mode.
 * @param day Days since last Sunday, 1 to 7.

HAL_StatusTypeDef DS3231_SetAlarm2Day(uint8_t day) {
	uint8_t temp;
	HAL_StatusTypeDef status;
	status = DS3231_ReadRegister(DS3231_REG_A2_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x80;
	uint8_t a2m4 = temp | (0x01 << DS3231_DYDT)
			| (DS3231_EncodeBCD(day) & 0x3F);
	return DS3231_WriteRegister(DS3231_REG_A2_DATE, &a2m4);
}

*
 * @brief Set alarm 2 mode.
 * @param alarmMode Alarm 2 mode, DS3231_A2_EVERY_M, DS3231_A2_MATCH_M, DS3231_A2_MATCH_M_H, DS3231_A2_MATCH_M_H_DATE or DS3231_A2_MATCH_M_H_DAY.

HAL_StatusTypeDef DS3231_SetAlarm2Mode(DS3231_Alarm2Mode alarmMode) {
	uint8_t temp;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_A2_MINUTE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 0) & 0x01) << DS3231_AXMY);
	return DS3231_WriteRegister(DS3231_REG_A2_MINUTE, &temp);

	status = DS3231_ReadRegister(DS3231_REG_A2_HOUR, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 1) & 0x01) << DS3231_AXMY);
	DS3231_WriteRegister(DS3231_REG_A2_HOUR, &temp);

	status = DS3231_ReadRegister(DS3231_REG_A2_DATE, &temp);
	if (status != HAL_OK)
		return status;
	temp &= 0x7F;
	temp = temp | (((alarmMode >> 2) & 0x01) << DS3231_AXMY)
			| (alarmMode & 0x80);
	DS3231_WriteRegister(DS3231_REG_A2_DATE, &temp);
}*/

HAL_StatusTypeDef DS3231_SetAlarm2(D3231_Alarm2 *A2_st) {
	HAL_StatusTypeDef status;
	uint8_t A2M2 = (A2_st->Mode & 0x01) << 7; // Minutes bit 7.
	uint8_t A2M3 = (A2_st->Mode & 0x02) << 6; // Hour bit 7.
	uint8_t A2M4 = (A2_st->Mode & 0x04) << 5; // Day/Date bit 7.
	uint8_t DY_DT = (A2_st->Mode & 0x08) << 3; // Day/Date bit 6. Date when 0, day of week when 1.

	uint8_t data[3] = {
			DS3231_EncodeBCD(A2_st->Minutes) | A2M2,
			DS3231_EncodeBCD(A2_st->Hours)	| A2M3,
			DS3231_EncodeBCD(A2_st->DayDate) | DY_DT| A2M4,
	};

	status = DS3231_WriteRegisters(DS3231_REG_A2_MINUTE, data, 3);
	if (status != HAL_OK)
			return status;
	return DS3231_SetAlarm2IntEn(A2_st->IntEn);
}

HAL_StatusTypeDef DS3231_GetAlarm2(D3231_Alarm2 *A2_st) {
	HAL_StatusTypeDef status;
	uint8_t data[3];
	status = DS3231_ReadRegisters(DS3231_REG_A2_MINUTE, data, 3);
	if (status != HAL_OK)
		return status;

	uint8_t Mode = (data[0] & 0x80) >> 7 	// A2M2
				 | (data[1] & 0x80) >> 6	// A2M3
				 | (data[2]& 0x80) >> 5		// A2M4
				 | (data[2] & 0x40) >> 3;	// DY_DT

	A2_st->Mode = Mode;

	A2_st->Minutes = DS3231_DecodeBCD(data[0] & 0x7F);
	A2_st->Hours = DS3231_DecodeBCD(data[1] & 0x7F);

	uint8_t DayDate =  (data[2] & 0x40) >> 6;
	if (DayDate)
		A2_st->DayDate = DS3231_DecodeBCD(data[2] & 0x0F);
	else
		A2_st->DayDate = DS3231_DecodeBCD(data[2] & 0x3F);

	return DS3231_GetAlarm2IntEn(&A2_st->IntEn);
}

/**
 * @brief Check if alarm 1 is triggered.
 * @return A1F flag bit, 0 or 1.
 */
HAL_StatusTypeDef DS3231_GetAlarm1Flag(DS3231_State *enable) {
	uint8_t data;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_STATUS, &data);
	*enable = (data >> DS3231_A1F) & 0x01;
	return status;
}

/**
 * @brief Check if alarm 2 is triggered.
 * @return A2F flag bit, 0 or 1.
 */
HAL_StatusTypeDef DS3231_GetAlarm2Flag(DS3231_State *enable) {
	uint8_t data;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_STATUS, &data);
	*enable = (data >> DS3231_A2F) & 0x01;
	return status;
}

/**
 * @brief Gets the current day of week.
 * @return Days from last Sunday, 0 to 6.

HAL_StatusTypeDef DS3231_GetDay(uint8_t *day) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_DAY, day);
	*day = DS3231_DecodeBCD(*day);
	return status;
}

*
 * @brief Gets the current day of month.
 * @return Day of month, 1 to 31.

HAL_StatusTypeDef DS3231_GetDate(uint8_t *date) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_DATE, date);
	*date = DS3231_DecodeBCD(*date);
	return status;
}

*
 * @brief Gets the current month.
 * @return Month, 1 to 12.

HAL_StatusTypeDef DS3231_GetMonth(uint8_t *month) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_MONTH, month);
	*month = DS3231_DecodeBCD(*month & 0x7F);
	return status;
}

*
 * @brief Gets the current year.
 * @return Year, 2000 to 2199.

HAL_StatusTypeDef DS3231_GetYear(uint16_t *year) {
	uint8_t decYear, century;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_YEAR, &decYear);
	if (status != HAL_OK)
		return status;
	decYear = DS3231_DecodeBCD(decYear);

	status = DS3231_ReadRegister(DS3231_REG_MONTH, &century);
	century = ((century >> DS3231_CENTURY) * 100) + 2000;

	*year = century + decYear;
	return status;
}

*
 * @brief Gets the current hour in 24h format.
 * @return Hour in 24h format, 0 to 23.

HAL_StatusTypeDef DS3231_GetHour(uint8_t *hour_24mode) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_HOUR, hour_24mode);
	*hour_24mode = DS3231_DecodeBCD(*hour_24mode);
	return status;
}

*
 * @brief Gets the current minute.
 * @return Minute, 0 to 59.

HAL_StatusTypeDef DS3231_GetMinute(uint8_t *minute) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_MINUTE, minute);
	*minute = DS3231_DecodeBCD(*minute);
	return status;
}

*
 * @brief Gets the current second. Clock halt bit not included.
 * @return Second, 0 to 59.

HAL_StatusTypeDef DS3231_GetSecond(uint8_t *second) {
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_SECOND, second);
	*second = DS3231_DecodeBCD(*second);
	return status;
}

HAL_StatusTypeDef DS3231_GetFullDate(uint8_t *day, uint8_t *date, uint8_t *month, uint16_t *year){
	HAL_StatusTypeDef status;

	status = DS3231_GetDay(day);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetDate(date);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetMonth(month);
	if (status != HAL_OK)
		return status;
	return DS3231_GetYear(year);
}

HAL_StatusTypeDef DS3231_GetFullTime(uint8_t *hour_24mode, uint8_t *minute, uint8_t *second){
	HAL_StatusTypeDef status;

	status = DS3231_GetHour(hour_24mode);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetMinute(minute);
	if (status != HAL_OK)
		return status;
	return DS3231_GetSecond(second);
}

HAL_StatusTypeDef DS3231_GetDateTime(uint8_t *day, uint8_t *date, uint8_t *month, uint16_t *year, uint8_t *hour_24mode, uint8_t *minute, uint8_t *second) {
	HAL_StatusTypeDef status;

	status = DS3231_GetDay(day);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetDate(date);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetMonth(month);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetYear(year);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetHour(hour_24mode);
	if (status != HAL_OK)
		return status;
	status = DS3231_GetMinute(minute);
	if (status != HAL_OK)
		return status;
	return DS3231_GetSecond(second);
}
*/

HAL_StatusTypeDef DS3231_GetDateTime(DS3231_DateTime *dt) {
	HAL_StatusTypeDef status;
	uint8_t buffer[7];

	status = DS3231_ReadRegisters(DS3231_REG_SECOND, buffer, 7);
	if (status != HAL_OK)
		return status;

	dt->Second =  DS3231_DecodeBCD(buffer[0] & 0x7F);
	dt->Minute =  DS3231_DecodeBCD(buffer[1] & 0x7F);
	dt->Hour_24mode =  DS3231_DecodeBCD(buffer[2] & 0x3F);
	dt->Day =  DS3231_DecodeBCD(buffer[3] & 0x07);
	dt->Date =  DS3231_DecodeBCD(buffer[4] & 0x3F);
	dt->Month =  DS3231_DecodeBCD(buffer[5] & 0x1F);
	dt->Year =  DS3231_DecodeBCD(buffer[6]) + 2000U;

	uint8_t regSTATUS;
	status = DS3231_ReadRegister(DS3231_REG_STATUS, &regSTATUS);
	if (status != HAL_OK)
		return status;
	regSTATUS &= (0x80);
	regSTATUS >>= DS3231_EOSC;

	dt->Enable = regSTATUS? DS3231_DISABLED : DS3231_ENABLED;

	return status;
}
/*
*
 * @brief Set the current day of week.
 * @param dayOfWeek Days since last Sunday, 1 to 7.

HAL_StatusTypeDef DS3231_SetDay(uint8_t *day) {
	uint8_t temp = DS3231_EncodeBCD(*day);
	return DS3231_WriteRegister(DS3231_REG_DAY, &temp);
}

*
 * @brief Set the current day of month.
 * @param date Day of month, 1 to 31.

HAL_StatusTypeDef DS3231_SetDate(uint8_t *date) {
	uint8_t temp = DS3231_EncodeBCD(*date);
	return DS3231_WriteRegister(DS3231_REG_DATE, &temp);
}

*
 * @brief Set the current month.
 * @param month Month, 1 to 12.

HAL_StatusTypeDef DS3231_SetMonth(uint8_t *month) {
	uint8_t century, temp;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_MONTH, &century);
	if (status != HAL_OK)
		return status;
	century &= 0x80;
	temp = DS3231_EncodeBCD(*month);
	temp |= century;
	return DS3231_WriteRegister(DS3231_REG_MONTH, &temp);
}

*
 * @brief Set the current year.
 * @param year Year, 2000 to 2199.

HAL_StatusTypeDef DS3231_SetYear(uint16_t *year) {
	uint8_t century = (*year / 100) % 20;
	uint8_t month;
	HAL_StatusTypeDef status;

	status = DS3231_ReadRegister(DS3231_REG_MONTH, &month);
	if (status != HAL_OK)
		return status;
	month &= 0x7F;
	month |= (century << DS3231_CENTURY);
	status = DS3231_WriteRegister(DS3231_REG_MONTH, &month);
	if (status != HAL_OK)
		return status;
	month = DS3231_EncodeBCD(*year % 100);
	return DS3231_WriteRegister(DS3231_REG_YEAR, &month);
}

*
 * @brief Set the current hour, in 24h format.
 * @param hour_24mode Hour in 24h format, 0 to 23.

HAL_StatusTypeDef DS3231_SetHour(uint8_t *hour_24mode) {
	uint8_t temp = DS3231_EncodeBCD(*hour_24mode & 0x3f);
	return DS3231_WriteRegister(DS3231_REG_HOUR, &temp);
}

*
 * @brief Set the current minute.
 * @param minute Minute, 0 to 59.

HAL_StatusTypeDef DS3231_SetMinute(uint8_t *minute) {
	uint8_t temp = DS3231_EncodeBCD(*minute);
	return DS3231_WriteRegister(DS3231_REG_MINUTE, &temp);
}

*
 * @brief Set the current second.
 * @param second Second, 0 to 59.

HAL_StatusTypeDef DS3231_SetSecond(uint8_t *second) {
	uint8_t temp = DS3231_EncodeBCD(*second);
	return DS3231_WriteRegister(DS3231_REG_SECOND, &temp);
}

*
 * @brief Set the current date, month, day of week and year.
 * @param date Date, 0 to 31.
 * @param month Month, 1 to 12.
 * @param dow Days since last Sunday, 1 to 7.
 * @param year Year, 2000 to 2199.

HAL_StatusTypeDef DS3231_SetFullDate( uint8_t *day, uint8_t *date, uint8_t *month, uint16_t *year) {
	HAL_StatusTypeDef status;

	status = DS3231_SetDay(day);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetDate(date);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetMonth(month);
	if (status != HAL_OK)
		return status;
	return DS3231_SetYear(year);
}

*
 * @brief Set the current time.
 * @param hour_24mode Hour in 24h format, 0 to 23.
 * @param minute  Minute, 0 to 59.
 * @param second Second, 0 to 59.

HAL_StatusTypeDef DS3231_SetFullTime(uint8_t *hour_24mode, uint8_t *minute, uint8_t *second) {
	HAL_StatusTypeDef status;

	status = DS3231_SetHour(hour_24mode);
	if (status != HAL_OK)
		return status;
	DS3231_SetMinute(minute);
	if (status != HAL_OK)
		return status;
	return DS3231_SetSecond(second);
}

HAL_StatusTypeDef DS3231_SetDateTime(uint8_t *day, uint8_t *date, uint8_t *month, uint16_t *year, uint8_t *hour_24mode, uint8_t *minute, uint8_t *second) {
	HAL_StatusTypeDef status;

	status = DS3231_SetDay(day);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetDate(date);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetMonth(month);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetYear(year);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetHour(hour_24mode);
	if (status != HAL_OK)
		return status;
	status = DS3231_SetMinute(minute);
	if (status != HAL_OK)
		return status;
	return DS3231_SetSecond(second);
}*/

HAL_StatusTypeDef DS3231_SetDateTime(DS3231_DateTime *dt) {
	HAL_StatusTypeDef status;
	uint8_t buffer[7];

	if ((dt->Day >= 1) | (dt->Day <= 7))
		buffer[3] = DS3231_EncodeBCD(dt->Day);
	else
		return HAL_ERROR;

	if ((dt->Date >= 1) | (dt->Date <= 31))
		buffer[4] = DS3231_EncodeBCD(dt->Date);
	else
		return HAL_ERROR;

	if ((dt->Month >= 1) | (dt->Month <= 12))			// Century bit implementation is pending
			buffer[5] = DS3231_EncodeBCD(dt->Month);
	else
		return HAL_ERROR;

	if ((dt->Year >= 0) | (dt->Year <= 99))
			buffer[6] = DS3231_EncodeBCD(dt->Year - 2000U);
	else
		return HAL_ERROR;

	if ((dt->Hour_24mode >= 0) | (dt->Hour_24mode <= 23))		// Only 24HR mode is supported
			buffer[2] = DS3231_EncodeBCD(dt->Hour_24mode);
	else
		return HAL_ERROR;

	if ((dt->Minute >= 0) | (dt->Minute <= 59))
			buffer[1] = DS3231_EncodeBCD(dt->Minute);
	else
		return HAL_ERROR;

	if ((dt->Second >= 0) | (dt->Second <= 59))
			buffer[0] = DS3231_EncodeBCD(dt->Second);
	else
		return HAL_ERROR;

	status  = DS3231_WriteRegisters(DS3231_REG_SECOND, buffer, 7);
	if (status != HAL_OK)
		return status;

	uint8_t regCONTROL;
	status = DS3231_ReadRegister(DS3231_REG_CONTROL, &regCONTROL);
	if (status != HAL_OK)
		return status;

	if (dt->Enable == DS3231_ENABLED)
		regCONTROL &= ~(0x80);
	else
		regCONTROL |= (0x80);

	return DS3231_WriteRegister(DS3231_REG_CONTROL, &regCONTROL);
}

void DS3231_ToUnixTime(DS3231_DateTime *dt, uint32_t *unixtime) {
	uint16_t days, years;
	uint8_t months, hours, minutes, seconds;
//	DS3231_DateTime dt;
//	HAL_StatusTypeDef status;

//	status = DS3231_GetDateTime(&temp, (uint8_t *)&days, &months, &years, &hours, &minutes, &seconds);
//	status = DS3231_GetDateTime_s(*dt);
//	if (status != HAL_OK)
//		return status;

	years = dt->Year;
	months = dt->Month;
	days = dt->Date;
	hours = dt->Hour_24mode;
	minutes = dt->Minute;
	seconds = dt->Second;


	 if (years >= 2000)
		 years -= 2000;
	 else
		 return;

	 days -= 1;
	 for (uint8_t i=1; i<months; i++)
		 days += days_in_month[i - 1];

	 if (months > 2 && years % 4 == 0)
		 days++;

	 days += (365 * years + (years + 3) / 4);

	 *unixtime = ((days * 24UL + hours) * 60 + minutes) * 60 + seconds + SECONDS_FROM_1970_TO_2000;
}

void DS3231_ToDateTime(uint32_t *unixtime, DS3231_DateTime *dt) {

    int32_t currYear, daysTillNow, extraTime, extraDays;
    uint8_t index, day, date, month, flag = 0;

    // Calculate total days unix time T
    daysTillNow = (*unixtime / (24 * 60 * 60));
    extraTime = (*unixtime % (24 * 60 * 60));
    currYear = 1970;

    // Calculating current year
    while (1) {
    	if (currYear % 400 == 0 || (currYear % 4 == 0 && currYear % 100 != 0)) {
            if (daysTillNow < 366) {
                break;
            }
            daysTillNow -= 366;
        }
        else {
            if (daysTillNow < 365) {
                break;
            }
            daysTillNow -= 365;
        }
        currYear += 1;
    }

    // Updating extradays because it
    // will give days till previous day
    // and we have include current day
    extraDays = daysTillNow + 1;

    if (currYear % 400 == 0 || (currYear % 4 == 0 && currYear % 100 != 0))
        flag = 1;

    // Calculating MONTH and DATE
    month = 0, index = 0;
    if (flag == 1) {
        while (1) {

            if (index == 1) {
                if (extraDays - 29 < 0)
                    break;
                month += 1;
                extraDays -= 29;
            }
            else {
                if (extraDays - days_in_month[index] < 0) {
                    break;
                }
                month += 1;
                extraDays -= days_in_month[index];
            }
            index += 1;
        }
    }
    else {
        while (1) {
            if (extraDays - days_in_month[index] < 0) {
                break;
            }
            month += 1;
            extraDays -= days_in_month[index];
            index += 1;
        }
    }

    // Current Month
    if (extraDays > 0) {
        month += 1;
        date = extraDays;
    }
    else {
        if (month == 2 && flag == 1)
            date = 29;
        else
            date = days_in_month[month - 1];
    }

    // Calculating HH:MM:YYYY

    dt->Date = (uint8_t)date;
    dt->Month = (uint8_t)month;
    dt->Year = (uint16_t)currYear;
    dt->Hour_24mode = extraTime / 3600;
    dt->Minute = (extraTime % 3600) / 60;
    dt->Second = (extraTime % 3600) % 60;

    currYear -= month < 3;
    day = (currYear + currYear / 4 - currYear / 100 + currYear / 400 + dow[month - 1] + date) % 7;
    if (day == 0)
        day = 7;

    dt->Day = day;
}

/**
 * @brief Writes the byte in the designated DS3231 register to value.
 * @param reg Register address to write.
 * @param data  Date to write, 0 to 255.
 * @return status of the execution of type HAL_StatusTypeDef
 */
HAL_StatusTypeDef DS3231_WriteRegister(uint8_t reg, uint8_t *data) {
	return HAL_I2C_Mem_Write(DS3231_device, DS3231_I2C_ADDR, reg, I2C_MEMADD_SIZE_8BIT, data, 1, DS3231_TIMEOUT);
}

/**
 * @brief Writes the byte in the designated DS3231 register to value.
 * @param reg Register address to write.
 * @param data  Date to write, 0 to 255.
 * @return status of the execution of type HAL_StatusTypeDef
 */
HAL_StatusTypeDef DS3231_WriteRegisters(uint8_t reg, uint8_t *data, uint8_t len) {
	return HAL_I2C_Mem_Write(DS3231_device, DS3231_I2C_ADDR, reg, I2C_MEMADD_SIZE_8BIT, data, len, DS3231_TIMEOUT);
}

/**
 * @brief Reads the byte in the designated DS3231 register.
 * @param reg Register address to read
 * @param data It return data read back to the pointer variable passed by data
 * @return status of the execution of type HAL_StatusTypeDef
 */
HAL_StatusTypeDef DS3231_ReadRegister(uint8_t reg, uint8_t *data) {
	return HAL_I2C_Mem_Read(DS3231_device, DS3231_I2C_ADDR, reg, I2C_MEMADD_SIZE_8BIT, data, 1, DS3231_TIMEOUT);
}

/**
 * @brief Reads the byte in the designated DS3231 register.
 * @param reg Register address to read
 * @param data It return data read back to the pointer variable passed by data
 * @return status of the execution of type HAL_StatusTypeDef
 */
HAL_StatusTypeDef DS3231_ReadRegisters(uint8_t reg, uint8_t *data, uint8_t len) {
	return HAL_I2C_Mem_Read(DS3231_device, DS3231_I2C_ADDR, reg, I2C_MEMADD_SIZE_8BIT, data, len, DS3231_TIMEOUT);
}

/**
 * @brief Decodes the raw binary value stored in registers to decimal format.
 * @param bin Binary-coded decimal value retrieved from register, 0 to 255.
 * @return Decoded decimal value.
 */
uint8_t DS3231_DecodeBCD(uint8_t bin) {
	return (((bin & 0xF0) >> 4) * 10) + (bin & 0x0F);
}

/**
 * @brief Encodes a decimal number to binaty-coded decimal for storage in registers.
 * @param dec Decimal number to encode.
 * @return Encoded binary-coded decimal value.
 */
uint8_t DS3231_EncodeBCD(uint8_t dec) {
	return (dec % 10 + ((dec / 10) << 4));
}

#ifdef __cplusplus
}
#endif
